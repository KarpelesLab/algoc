// MD5 message-digest algorithm implementation in AlgoC
//
// This implements the MD5 hash function as specified in RFC 1321.
// Note: MD5 is cryptographically broken and should not be used for security.

use "../runtime.algoc";

// Per-round shift amounts
const MD5_S: u32[64] = [
    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
    5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
];

// Precomputed table of constants (floor(2^32 * abs(sin(i+1))))
const MD5_K: u32[64] = [
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
];

// Initial hash values
const MD5_H_INIT: u32[4] = [
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
];

// MD5 state
struct Md5State {
    h: u32[4],           // Current hash value (a, b, c, d)
    block: u8[64],       // Current block buffer
    block_len: u8,       // Bytes in current block
    total_len: u64       // Total message length in bytes
}

// Implement the Hash interface for Md5State
impl Md5State {
    // Create a new initialized hash state
    static fn new() -> Self {
        let mut state: Md5State;
        for i in 0..4 {
            state.h[i] = MD5_H_INIT[i];
        }
        state.block_len = 0;
        state.total_len = 0;
        return state;
    }

    // MD5 uses a 64-byte (512-bit) block
    static fn block_size() -> u64 {
        return 64;
    }

    // MD5 produces a 16-byte (128-bit) digest
    static fn output_size() -> u64 {
        return 16;
    }

    // Update with more data
    fn update(&mut self, data: &[u8]) {
        md5_update(self, data);
    }

    // Finalize and write digest
    fn finalize(&mut self, output: &mut [u8]) {
        md5_final(self, output);
    }

    // Reset to initial state
    fn reset(&mut self) {
        for i in 0..4 {
            self.h[i] = H_INIT[i];
        }
        self.block_len = 0;
        self.total_len = 0;
    }
}

// Initialize MD5 state
fn md5_init(state: &mut Md5State) {
    for i in 0..4 {
        state.h[i] = MD5_H_INIT[i];
    }
    state.block_len = 0;
    state.total_len = 0;
}

// MD5 compression function
fn md5_compress(state: &mut Md5State, block: &[u8; 64]) {
    // Message schedule array (16 32-bit words, little-endian)
    let mut m: u32[16];

    for i in 0..16 {
        m[i] = read_u32_le(block, i * 4);
    }

    // Working variables
    let mut a = state.h[0];
    let mut b = state.h[1];
    let mut c = state.h[2];
    let mut d = state.h[3];

    // 64 rounds
    for i in 0..64 {
        let mut f: u32;
        let mut g: u32;

        if i < 16 {
            // Round 1: F(B, C, D) = (B and C) or ((not B) and D)
            f = (b & c) | ((~b) & d);
            g = i;
        } else if i < 32 {
            // Round 2: G(B, C, D) = (B and D) or (C and (not D))
            f = (d & b) | (c & (~d));
            g = (5 * i + 1) % 16;
        } else if i < 48 {
            // Round 3: H(B, C, D) = B xor C xor D
            f = b ^ c ^ d;
            g = (3 * i + 5) % 16;
        } else {
            // Round 4: I(B, C, D) = C xor (B or (not D))
            f = c ^ (b | (~d));
            g = (7 * i) % 16;
        }

        f = f + a + MD5_K[i] + m[g];
        a = d;
        d = c;
        c = b;
        b = b + rotl(f, MD5_S[i]);
    }

    // Update state
    state.h[0] = state.h[0] + a;
    state.h[1] = state.h[1] + b;
    state.h[2] = state.h[2] + c;
    state.h[3] = state.h[3] + d;
}

// Update MD5 with more data
fn md5_update(state: &mut Md5State, data: &[u8]) {
    let data_len = data.len();
    let mut offset: u64 = 0;

    // Process any remaining data in the buffer
    while state.block_len > 0 && offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;

        if state.block_len == 64 {
            md5_compress(state, &state.block);
            state.block_len = 0;
        }
    }

    // Process full blocks directly
    while offset + 64 <= data_len {
        let block_ref = data[offset..offset + 64];
        md5_compress(state, block_ref);
        offset = offset + 64;
    }

    // Buffer remaining data
    while offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;
    }

    state.total_len = state.total_len + data_len;
}

// Finalize MD5 and produce digest
fn md5_final(state: &mut Md5State, digest: &mut [u8; 16]) {
    // Pad message
    let bit_len = state.total_len * 8;

    // Append the bit '1' to message (0x80 byte)
    state.block[state.block_len] = 0x80;
    state.block_len = state.block_len + 1;

    // If not enough room for length, pad and compress
    if state.block_len > 56 {
        while state.block_len < 64 {
            state.block[state.block_len] = 0;
            state.block_len = state.block_len + 1;
        }
        md5_compress(state, &state.block);
        state.block_len = 0;
    }

    // Pad to 56 bytes
    while state.block_len < 56 {
        state.block[state.block_len] = 0;
        state.block_len = state.block_len + 1;
    }

    // Append length in bits as 64-bit little-endian
    write_u64_le(&mut state.block, 56, bit_len);
    md5_compress(state, &state.block);

    // Output digest (little-endian)
    for i in 0..4 {
        write_u32_le(digest, i * 4, state.h[i]);
    }

    // Secure cleanup
    secure_zero(&mut state.h);
    secure_zero(&mut state.block);
}

// Convenience function: hash a complete message
fn md5(message: &[u8], digest: &mut [u8; 16]) {
    let mut state: Md5State;
    md5_init(&mut state);
    md5_update(&mut state, message);
    md5_final(&mut state, digest);
}

// Test vectors from RFC 1321
test md5_empty() {
    let mut digest: [u8; 16];
    md5(bytes(""), &mut digest);
    assert(digest == hex("d41d8cd98f00b204e9800998ecf8427e"));
}

test md5_a() {
    let mut digest: [u8; 16];
    md5(bytes("a"), &mut digest);
    assert(digest == hex("0cc175b9c0f1b6a831c399e269772661"));
}

test md5_abc() {
    let mut digest: [u8; 16];
    md5(bytes("abc"), &mut digest);
    assert(digest == hex("900150983cd24fb0d6963f7d28e17f72"));
}

test md5_message_digest() {
    let mut digest: [u8; 16];
    md5(bytes("message digest"), &mut digest);
    assert(digest == hex("f96b697d7cb7938d525a2f31aaf161d0"));
}

test md5_alphabet() {
    let mut digest: [u8; 16];
    md5(bytes("abcdefghijklmnopqrstuvwxyz"), &mut digest);
    assert(digest == hex("c3fcd3d76192e4007dfb496cca67e13b"));
}

test md5_alphanumeric() {
    let mut digest: [u8; 16];
    md5(bytes("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"), &mut digest);
    assert(digest == hex("d174ab98d277d9f5a5611c2c9f419d9f"));
}

test md5_numeric() {
    let mut digest: [u8; 16];
    md5(bytes("12345678901234567890123456789012345678901234567890123456789012345678901234567890"), &mut digest);
    assert(digest == hex("57edf4a22be3c955ac49da2e2107b67a"));
}
