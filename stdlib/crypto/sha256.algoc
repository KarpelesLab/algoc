// SHA-256 hash function implementation in AlgoC
//
// This implements the SHA-256 cryptographic hash function as specified
// in FIPS 180-4.

use "../runtime.algoc";

// Round constants (first 32 bits of fractional parts of cube roots of first 64 primes)
const K: u32[64] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

// Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
const H_INIT: u32[8] = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
];

// SHA-256 state
struct Sha256State {
    h: u32[8],           // Current hash value
    block: u8[64],       // Current block buffer
    block_len: u8,       // Bytes in current block
    total_len: u64       // Total message length in bytes
}

// Implement the Hash interface for Sha256State
impl Sha256State {
    // Create a new initialized hash state
    static fn new() -> Self {
        let mut state: Sha256State;
        for i in 0..8 {
            state.h[i] = H_INIT[i];
        }
        state.block_len = 0;
        state.total_len = 0;
        return state;
    }

    // SHA-256 uses a 64-byte (512-bit) block
    static fn block_size() -> u64 {
        return 64;
    }

    // SHA-256 produces a 32-byte (256-bit) digest
    static fn output_size() -> u64 {
        return 32;
    }

    // Update with more data
    fn update(&mut self, data: &[u8]) {
        sha256_update(self, data);
    }

    // Finalize and write digest
    fn finalize(&mut self, output: &mut [u8]) {
        sha256_final(self, output);
    }

    // Reset to initial state
    fn reset(&mut self) {
        for i in 0..8 {
            self.h[i] = H_INIT[i];
        }
        self.block_len = 0;
        self.total_len = 0;
    }
}

// Initialize SHA-256 state
fn sha256_init(state: &mut Sha256State) {
    for i in 0..8 {
        state.h[i] = H_INIT[i];
    }
    state.block_len = 0;
    state.total_len = 0;
}

// SHA-256 compression function
fn sha256_compress(state: &mut Sha256State, block: &[u8; 64]) {
    // Message schedule array
    let mut w: u32[64];

    // Prepare message schedule
    for i in 0..16 {
        w[i] = read_u32_be(block, i * 4);
    }

    for i in 16..64 {
        let s0 = rotr(w[i - 15], 7) ^ rotr(w[i - 15], 18) ^ (w[i - 15] >> 3);
        let s1 = rotr(w[i - 2], 17) ^ rotr(w[i - 2], 19) ^ (w[i - 2] >> 10);
        w[i] = w[i - 16] + s0 + w[i - 7] + s1;
    }

    // Working variables
    let mut a = state.h[0];
    let mut b = state.h[1];
    let mut c = state.h[2];
    let mut d = state.h[3];
    let mut e = state.h[4];
    let mut f = state.h[5];
    let mut g = state.h[6];
    let mut h = state.h[7];

    // Compression loop
    for i in 0..64 {
        let S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
        let ch = (e & f) ^ ((~e) & g);
        let temp1 = h + S1 + ch + K[i] + w[i];
        let S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
        let maj = (a & b) ^ (a & c) ^ (b & c);
        let temp2 = S0 + maj;

        h = g;
        g = f;
        f = e;
        e = d + temp1;
        d = c;
        c = b;
        b = a;
        a = temp1 + temp2;
    }

    // Update state
    state.h[0] = state.h[0] + a;
    state.h[1] = state.h[1] + b;
    state.h[2] = state.h[2] + c;
    state.h[3] = state.h[3] + d;
    state.h[4] = state.h[4] + e;
    state.h[5] = state.h[5] + f;
    state.h[6] = state.h[6] + g;
    state.h[7] = state.h[7] + h;
}

// Update SHA-256 with more data
fn sha256_update(state: &mut Sha256State, data: &[u8]) {
    let data_len = data.len();
    let mut offset: u64 = 0;

    // Process any remaining data in the buffer
    while state.block_len > 0 && offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;

        if state.block_len == 64 {
            sha256_compress(state, &state.block);
            state.block_len = 0;
        }
    }

    // Process full blocks directly
    while offset + 64 <= data_len {
        // Get the 64-byte slice (slicing already returns a reference)
        let block_ref = data[offset..offset + 64];
        sha256_compress(state, block_ref);
        offset = offset + 64;
    }

    // Buffer remaining data
    while offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;
    }

    state.total_len = state.total_len + data_len;
}

// Finalize SHA-256 and produce digest
fn sha256_final(state: &mut Sha256State, digest: &mut [u8; 32]) {
    // Pad message
    let bit_len = state.total_len * 8;

    // Append the bit '1' to message (0x80 byte)
    state.block[state.block_len] = 0x80;
    state.block_len = state.block_len + 1;

    // If not enough room for length, pad and compress
    if state.block_len > 56 {
        while state.block_len < 64 {
            state.block[state.block_len] = 0;
            state.block_len = state.block_len + 1;
        }
        sha256_compress(state, &state.block);
        state.block_len = 0;
    }

    // Pad to 56 bytes
    while state.block_len < 56 {
        state.block[state.block_len] = 0;
        state.block_len = state.block_len + 1;
    }

    // Append length in bits as 64-bit big-endian
    write_u64_be(&mut state.block, 56, bit_len);
    sha256_compress(state, &state.block);

    // Output digest (big-endian)
    for i in 0..8 {
        write_u32_be(digest, i * 4, state.h[i]);
    }

    // Secure cleanup
    secure_zero(&mut state.h);
    secure_zero(&mut state.block);
}

// Convenience function: hash a complete message
fn sha256(message: &[u8], digest: &mut [u8; 32]) {
    let mut state: Sha256State;
    sha256_init(&mut state);
    sha256_update(&mut state, message);
    sha256_final(&mut state, digest);
}

// Update SHA-256 state by reading from a Reader until EOF
fn sha256_update_from_reader(state: &mut Sha256State, reader: Reader) {
    while !reader.eof() {
        let chunk: &[u8] = reader.read_chunk(4096);
        sha256_update(state, chunk);
    }
}

// Convenience function: hash data from a Reader
fn sha256_reader(reader: Reader, digest: &mut [u8; 32]) {
    let mut state: Sha256State;
    sha256_init(&mut state);
    sha256_update_from_reader(&mut state, reader);
    sha256_final(&mut state, digest);
}

// Test vectors from FIPS 180-4
test sha256_empty() {
    let mut digest: [u8; 32];
    sha256(bytes(""), &mut digest);
    assert(digest == hex("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"));
}

test sha256_abc() {
    let mut digest: [u8; 32];
    sha256(bytes("abc"), &mut digest);
    assert(digest == hex("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"));
}

test sha256_long() {
    let mut digest: [u8; 32];
    sha256(bytes("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"), &mut digest);
    assert(digest == hex("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"));
}

// Test streaming from Reader
test sha256_reader_abc() {
    let data: &[u8] = bytes("abc");
    let reader: Reader = Reader(data);
    let mut digest: [u8; 32];
    sha256_reader(reader, &mut digest);
    // Should match sha256("abc")
    assert(digest == hex("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"));
}

test sha256_reader_long() {
    let data: &[u8] = bytes("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    let reader: Reader = Reader(data);
    let mut digest: [u8; 32];
    sha256_reader(reader, &mut digest);
    // Should match sha256 of the same string
    assert(digest == hex("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"));
}

test sha256_reader_chunked() {
    // Test that streaming in small chunks produces the same result
    let data: &[u8] = bytes("The quick brown fox jumps over the lazy dog");
    let reader: Reader = Reader(data);
    let mut digest_reader: [u8; 32];
    sha256_reader(reader, &mut digest_reader);

    // Compare with direct hash
    let mut digest_direct: [u8; 32];
    sha256(data, &mut digest_direct);

    // Use slicing to ensure array comparison (not reference comparison)
    assert(digest_reader[0..32] == digest_direct[0..32]);
}
