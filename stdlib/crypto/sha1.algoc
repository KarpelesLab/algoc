// SHA-1 hash function implementation in AlgoC
//
// This implements the SHA-1 cryptographic hash function as specified
// in FIPS 180-4. Note: SHA-1 is considered cryptographically broken
// and should not be used for security purposes. Use SHA-256 instead.

use "../runtime.algoc";

// Round constants
const K0: u32 = 0x5A827999;  // Rounds 0-19
const K1: u32 = 0x6ED9EBA1;  // Rounds 20-39
const K2: u32 = 0x8F1BBCDC;  // Rounds 40-59
const K3: u32 = 0xCA62C1D6;  // Rounds 60-79

// Initial hash values
const H0_INIT: u32 = 0x67452301;
const H1_INIT: u32 = 0xEFCDAB89;
const H2_INIT: u32 = 0x98BADCFE;
const H3_INIT: u32 = 0x10325476;
const H4_INIT: u32 = 0xC3D2E1F0;

// SHA-1 state
struct Sha1State {
    h0: u32,
    h1: u32,
    h2: u32,
    h3: u32,
    h4: u32,
    block: u8[64],       // Current block buffer
    block_len: u8,       // Bytes in current block
    total_len: u64       // Total message length in bytes
}

// Initialize SHA-1 state
fn sha1_init(state: &mut Sha1State) {
    state.h0 = H0_INIT;
    state.h1 = H1_INIT;
    state.h2 = H2_INIT;
    state.h3 = H3_INIT;
    state.h4 = H4_INIT;
    state.block_len = 0;
    state.total_len = 0;
}

// SHA-1 compression function
fn sha1_compress(state: &mut Sha1State, block: &[u8; 64]) {
    // Message schedule array
    let mut w: u32[80];

    // Prepare message schedule (first 16 words from block)
    for i in 0..16 {
        w[i] = read_u32_be(block, i * 4);
    }

    // Extend message schedule
    for i in 16..80 {
        w[i] = rotl(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
    }

    // Working variables
    let mut a = state.h0;
    let mut b = state.h1;
    let mut c = state.h2;
    let mut d = state.h3;
    let mut e = state.h4;

    // Compression loop
    for i in 0..80 {
        let mut f: u32;
        let mut k: u32;

        if i < 20 {
            f = (b & c) | ((~b) & d);
            k = K0;
        } else if i < 40 {
            f = b ^ c ^ d;
            k = K1;
        } else if i < 60 {
            f = (b & c) | (b & d) | (c & d);
            k = K2;
        } else {
            f = b ^ c ^ d;
            k = K3;
        }

        let temp = rotl(a, 5) + f + e + k + w[i];
        e = d;
        d = c;
        c = rotl(b, 30);
        b = a;
        a = temp;
    }

    // Update state
    state.h0 = state.h0 + a;
    state.h1 = state.h1 + b;
    state.h2 = state.h2 + c;
    state.h3 = state.h3 + d;
    state.h4 = state.h4 + e;
}

// Update SHA-1 with more data
fn sha1_update(state: &mut Sha1State, data: &[u8]) {
    let data_len = data.len();
    let mut offset: u64 = 0;

    // Process any remaining data in the buffer
    while state.block_len > 0 && offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;

        if state.block_len == 64 {
            sha1_compress(state, &state.block);
            state.block_len = 0;
        }
    }

    // Process full blocks directly
    while offset + 64 <= data_len {
        let block_ref = data[offset..offset + 64];
        sha1_compress(state, block_ref);
        offset = offset + 64;
    }

    // Buffer remaining data
    while offset < data_len {
        state.block[state.block_len] = data[offset];
        state.block_len = state.block_len + 1;
        offset = offset + 1;
    }

    state.total_len = state.total_len + data_len;
}

// Finalize SHA-1 and produce digest
fn sha1_final(state: &mut Sha1State, digest: &mut [u8; 20]) {
    // Pad message
    let bit_len = state.total_len * 8;

    // Append the bit '1' to message (0x80 byte)
    state.block[state.block_len] = 0x80;
    state.block_len = state.block_len + 1;

    // If not enough room for length, pad and compress
    if state.block_len > 56 {
        while state.block_len < 64 {
            state.block[state.block_len] = 0;
            state.block_len = state.block_len + 1;
        }
        sha1_compress(state, &state.block);
        state.block_len = 0;
    }

    // Pad to 56 bytes
    while state.block_len < 56 {
        state.block[state.block_len] = 0;
        state.block_len = state.block_len + 1;
    }

    // Append length in bits as 64-bit big-endian
    write_u64_be(&mut state.block, 56, bit_len);
    sha1_compress(state, &state.block);

    // Output digest (big-endian)
    write_u32_be(digest, 0, state.h0);
    write_u32_be(digest, 4, state.h1);
    write_u32_be(digest, 8, state.h2);
    write_u32_be(digest, 12, state.h3);
    write_u32_be(digest, 16, state.h4);
}

// Convenience function: hash a complete message
fn sha1(message: &[u8], digest: &mut [u8; 20]) {
    let mut state: Sha1State;
    sha1_init(&mut state);
    sha1_update(&mut state, message);
    sha1_final(&mut state, digest);
}

// Test vectors from FIPS 180-4
test sha1_empty() {
    let mut digest: u8[20];
    sha1(bytes(""), &mut digest);
    assert(digest == hex("da39a3ee5e6b4b0d3255bfef95601890afd80709"));
}

test sha1_abc() {
    let mut digest: u8[20];
    sha1(bytes("abc"), &mut digest);
    assert(digest == hex("a9993e364706816aba3e25717850c26c9cd0d89d"));
}

test sha1_long() {
    let mut digest: u8[20];
    sha1(bytes("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"), &mut digest);
    assert(digest == hex("84983e441c3bd26ebaae4aa1f95129e5e54670f1"));
}

test sha1_lazy_dog() {
    let mut digest: u8[20];
    sha1(bytes("The quick brown fox jumps over the lazy dog"), &mut digest);
    assert(digest == hex("2fd4e1c67a2d28fced849ee1bb76e7391b93eb12"));
}
